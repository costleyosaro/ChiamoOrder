# customers/serializers.py
from rest_framework import serializers
from .models import User
from rest_framework.views import APIView


class UserSerializer(serializers.ModelSerializer):
    # Map frontend camelCase keys to model snake_case fields
    businessName = serializers.CharField(source="business_name")
    salesExecutive = serializers.CharField(
        source="sales_executive", allow_blank=True, required=False
    )
    shopPhotoUrl = serializers.URLField(
     source="shop_photo_url", allow_blank=True, required=False
    )

    # Password handling
    password = serializers.CharField(write_only=True, required=True, min_length=6)
    confirmPassword = serializers.CharField(write_only=True, required=True)

    # QR code is read-only (generated by model.save)
    qr_code = serializers.ImageField(read_only=True)

    class Meta:
        model = User
        # fields exposed to client; timestamp and qr_code are read-only
        fields = [
            "id",
            "name",
            "businessName",
            "phone",
            "email",
            "password",
            "confirmPassword",
            "salesExecutive",
            "location",
            "latitude",
            "longitude",
            "timestamp",
            "shopPhotoUrl",
            "qr_code",
            "theme"
        ]
        read_only_fields = ["id", "timestamp", "qr_code"]

    def validate(self, attrs):
        """
        Ensure password and confirmPassword match and PIN / other checks if needed.
        Note: because we used `source=...` for some fields, validated_data will contain
        keys using model field names (e.g. 'business_name'), but password/confirmPassword
        remain as defined here.
        """
        pwd = attrs.get("password")
        confirm = attrs.get("confirmPassword")
        if pwd != confirm:
            raise serializers.ValidationError(
                {"confirmPassword": "Password and confirm password do not match."}
            )
        return attrs

    def create(self, validated_data):
        """
        Create a new User. validated_data uses model field names because of `source` mapping.
        Remove confirmPassword before creating.
        """
        # remove confirmPassword (not a model field)
        validated_data.pop("confirmPassword", None)

        # password value
        password = validated_data.pop("password")

        # Use the manager helper to create user (it sets the password)
        user = User.objects.create_user(password=password, **validated_data)
        return user


# ---------- PIN serializers ----------
class SetPinSerializer(serializers.Serializer):
    customer_id = serializers.IntegerField()
    pin = serializers.CharField(min_length=4, max_length=4, write_only=True)

    def validate_pin(self, value):
        if not value.isdigit():
            raise serializers.ValidationError("PIN must be 4 digits only.")
        return value


class ValidatePinSerializer(serializers.Serializer):
    customer_id = serializers.IntegerField()
    pin = serializers.CharField(min_length=4, max_length=4, write_only=True)

    def validate_pin(self, value):
        if not value.isdigit():
            raise serializers.ValidationError("PIN must be 4 digits only.")
        return value


class ResetPinSerializer(serializers.Serializer):
    """
    Reset PIN with either old_pin or account password.
    """
    user_id = serializers.IntegerField()
    old_pin = serializers.CharField(min_length=4, max_length=4, required=False, allow_blank=True, write_only=True)
    password = serializers.CharField(required=False, allow_blank=True, write_only=True)
    new_pin = serializers.CharField(min_length=4, max_length=4, write_only=True)

    def validate_new_pin(self, value):
        if not value.isdigit():
            raise serializers.ValidationError("New PIN must be exactly 4 digits.")
        return value

    def validate(self, attrs):
        if not attrs.get("old_pin") and not attrs.get("password"):
            raise serializers.ValidationError("Provide either 'old_pin' or 'password' to reset PIN.")
        return attrs

from rest_framework import serializers
from django.contrib.auth import authenticate
from .models import User


class LoginSerializer(serializers.Serializer):
    business_name = serializers.CharField()
    password = serializers.CharField(write_only=True)

    def validate(self, data):
        business_name = data.get("business_name")
        password = data.get("password")

        if not business_name or not password:
            raise serializers.ValidationError("Both business_name and password are required.")

        user = authenticate(username=business_name, password=password)
        if not user:
            raise serializers.ValidationError("Invalid login credentials.")

        data["user"] = user
        return data

from rest_framework import serializers
from django.contrib.auth.tokens import default_token_generator
from rest_framework import serializers
from .models import User


class ForgotPasswordSerializer(serializers.Serializer):
    email = serializers.EmailField()

    def validate_email(self, value):
        try:
            user = User.objects.get(email=value)
        except User.DoesNotExist:
            raise serializers.ValidationError("No account found with this email.")
        return value


class VerifyOtpSerializer(serializers.Serializer):
    email = serializers.EmailField()
    otp = serializers.CharField(min_length=4, max_length=4)

    def validate(self, data):
        try:
            user = User.objects.get(email=data["email"])
        except User.DoesNotExist:
            raise serializers.ValidationError("Invalid user.")

        if not user.validate_reset_otp(data["otp"]):
            raise serializers.ValidationError("Invalid or expired OTP.")

        return data


class ResetPasswordSerializer(serializers.Serializer):
    email = serializers.EmailField()
    otp = serializers.CharField(min_length=4, max_length=4)
    new_password = serializers.CharField(min_length=6)

    def validate(self, data):
        try:
            user = User.objects.get(email=data["email"])
        except User.DoesNotExist:
            raise serializers.ValidationError("Invalid user.")

        if not user.validate_reset_otp(data["otp"]):
            raise serializers.ValidationError("Invalid or expired OTP.")

        return data

    def save(self, **kwargs):
        user = User.objects.get(email=self.validated_data["email"])
        user.set_password(self.validated_data["new_password"])
        user.reset_otp = None  # clear OTP after use
        user.otp_created_at = None
        user.save()
        return user


# customers/serializers.py

class ProfileUpdateSerializer(serializers.ModelSerializer):
    """
    Used for editing profile in frontend.
    Includes all editable fields except password/PIN.
    """

    businessName = serializers.CharField(source="business_name", read_only=True)
    salesExecutive = serializers.CharField(
        source="sales_executive", allow_blank=True, required=False
    )
    shopPhotoUrl = serializers.URLField(
        source="shop_photo_url", allow_blank=True, required=False
    )

    class Meta:
        model = User
        fields = [
            "id",
            "name",
            "businessName",
            "email",
            "phone",
            "location",
            "salesExecutive",
            "latitude",
            "longitude",
            "shopPhotoUrl",
            "theme",
            "qr_code",
        ]
        read_only_fields = ["id", "businessName", "qr_code"]

    def update(self, instance, validated_data):
        # handle nested mappings (source=...)
        for attr, value in validated_data.items():
            setattr(instance, attr, value)
        instance.save()
        return instance


from rest_framework import serializers
from .models import Address

class AddressSerializer(serializers.ModelSerializer):
    class Meta:
        model = Address
        fields = '__all__'
        read_only_fields = ['user']
